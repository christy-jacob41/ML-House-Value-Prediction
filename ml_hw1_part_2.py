# -*- coding: utf-8 -*-
"""ML HW1 Part 2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xEhXi15panAuothPSlXCw2iDyursh05L
"""

# importing pandas, matplotlib, and seaborn
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# importing real estate evaluation dataset
file = 'https://archive.ics.uci.edu/ml/machine-learning-databases/00477/Real%20estate%20valuation%20data%20set.xlsx'
df = pd.read_excel(file)

print(df)

# dropping row if there are missing values or NA
df = df.dropna(axis=0)
print(df)

# dropping duplicates and updating the dataframe
df.drop_duplicates(keep='first', inplace=True)
print(df)

# no categorical variables to worry about

# the "No" column is unnecessary so I will drop it
df = df.drop(columns=['No'])
print(df)

sns.set(rc={'figure.figsize':(11.7,8.27)})
sns.distplot(df['X2 house age'], bins=50)
plt.show()

sns.distplot(df['X3 distance to the nearest MRT station'], bins=50)

sns.distplot(df['X4 number of convenience stores'], bins=50)

sns.distplot(df['X1 transaction date'], bins=50)

sns.distplot(df['Y house price of unit area'], bins=50)

# creating a correlation matrix
correlation_matrix = df.corr().round(2)

# showing heat map of correlation matrix
sns.heatmap(data=correlation_matrix, annot=True)

# normalizing data as part of preprocessing
from sklearn.preprocessing import StandardScaler

X = df[['X1 transaction date', 'X2 house age', 'X3 distance to the nearest MRT station', 'X4 number of convenience stores', 'X5 latitude', 'X6 longitude']]
Y = df['Y house price of unit area']

# transforming data to make it become standardized(normalized) using StandardScaler
s = StandardScaler()
X = pd.DataFrame(s.fit(X).fit_transform(X))
print(X)

print(Y)

# using train_test_split to split dataframe into trainig and testing dataset
from sklearn.model_selection import train_test_split

# using an 80% training and 20% testing split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)
print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_test.shape)

# importing from scikit learn
from sklearn.linear_model import SGDRegressor
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score

# using gradient descent and defaults to build model
model = SGDRegressor()
model.fit(X_train, Y_train)

model.coef_

model.n_iter_

model.intercept_

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

plot1 = pd.DataFrame(columns = ['Iterations', 'RMSE', 'R Squared'])
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 2
model = SGDRegressor(learning_rate='constant', eta0=0.001)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")

plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 3
model = SGDRegressor(learning_rate='optimal', eta0=0.1)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 4
model = SGDRegressor(learning_rate='adaptive', eta0=0.1)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 5
X = df[['X2 house age', 'X3 distance to the nearest MRT station', 'X4 number of convenience stores', 'X5 latitude', 'X6 longitude']]
Y = df['Y house price of unit area']

# transforming data to make it become standardized(normalized) using StandardScaler
s = StandardScaler()
X = pd.DataFrame(s.fit(X).fit_transform(X))

# using an 80% training and 20% testing split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)
print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_test.shape)

model = SGDRegressor(learning_rate='adaptive', eta0=0.4)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 6
X = df[['X2 house age', 'X3 distance to the nearest MRT station']]
Y = df['Y house price of unit area']

# transforming data to make it become standardized(normalized) using StandardScaler
s = StandardScaler()
X = pd.DataFrame(s.fit(X).fit_transform(X))

# using an 80% training and 20% testing split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)
print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_test.shape)

model = SGDRegressor(learning_rate='adaptive', eta0=0.1)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 7
X = df[['X2 house age', 'X3 distance to the nearest MRT station', 'X4 number of convenience stores', 'X5 latitude', 'X6 longitude']]
Y = df['Y house price of unit area']

# transforming data to make it become standardized(normalized) using StandardScaler
s = StandardScaler()
X = pd.DataFrame(s.fit(X).fit_transform(X))

# using an 80% training and 20% testing split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)
print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_test.shape)

model = SGDRegressor(learning_rate='adaptive', tol = 0.00000001, eta0 = 0.1)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 8
X = df[['X2 house age', 'X3 distance to the nearest MRT station', 'X4 number of convenience stores', 'X5 latitude', 'X6 longitude']]
Y = df['Y house price of unit area']

# transforming data to make it become standardized(normalized) using StandardScaler
s = StandardScaler()
X = pd.DataFrame(s.fit(X).fit_transform(X))

# using an 80% training and 20% testing split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)
print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_test.shape)

model = SGDRegressor(learning_rate='invscaling', tol = 0.00000001, eta0=0.1)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 9
X = df[['X3 distance to the nearest MRT station', 'X4 number of convenience stores', 'X5 latitude', 'X6 longitude']]
Y = df['Y house price of unit area']

# transforming data to make it become standardized(normalized) using StandardScaler
s = StandardScaler()
X = pd.DataFrame(s.fit(X).fit_transform(X))

# using an 80% training and 20% testing split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)
print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_test.shape)

model = SGDRegressor(learning_rate='adaptive', tol = 0.001, eta0=0.1)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 10
X = df[['X2 house age', 'X3 distance to the nearest MRT station', 'X4 number of convenience stores', 'X5 latitude', 'X6 longitude']]
Y = df['Y house price of unit area']

# transforming data to make it become standardized(normalized) using StandardScaler
s = StandardScaler()
X = pd.DataFrame(s.fit(X).fit_transform(X))

# using an 80% training and 20% testing split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)
print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_test.shape)

model = SGDRegressor(eta0=0.1, learning_rate='adaptive', tol = 0.001, n_iter_no_change=20)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

# trial 11
X = df[['X2 house age', 'X3 distance to the nearest MRT station', 'X5 latitude', 'X6 longitude']]
Y = df['Y house price of unit area']

# transforming data to make it become standardized(normalized) using StandardScaler
s = StandardScaler()
X = pd.DataFrame(s.fit(X).fit_transform(X))

# using an 80% training and 20% testing split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state=5)
print(X_train.shape)
print(X_test.shape)
print(Y_train.shape)
print(Y_test.shape)

model = SGDRegressor(learning_rate='adaptive', tol = 0.001, n_iter_no_change=10, eta0=0.1)
model.fit(X_train, Y_train)

print(model.coef_)
print(model.n_iter_)
print(model.intercept_)

# seeing if there is error
y_train_predict = model.predict(X_train)
rmse = (np.sqrt(mean_squared_error(Y_train, y_train_predict)))

# r squared error - fraction of variance explained by the model
r2 = r2_score(Y_train, y_train_predict)

print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))
print("\n")
plot1 = plot1.append({'Iterations' : model.n_iter_, 'RMSE' : rmse, 'R Squared' : r2}, ignore_index = True)

# getting error and r squared value of the testing data set

# model evaluation for testing set
y_test_predict = model.predict(X_test)
rmse = (np.sqrt(mean_squared_error(Y_test, y_test_predict)))
r2 = r2_score(Y_test, y_test_predict)

print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse))
print('R2 score is {}'.format(r2))

df.plot.scatter(x = 'X3 distance to the nearest MRT station', y = 'Y house price of unit area')

df.plot.scatter(x = 'X2 house age', y = 'Y house price of unit area')

df.plot.scatter(x = 'X1 transaction date', y = 'Y house price of unit area')

df.plot.scatter(x = 'X4 number of convenience stores', y = 'Y house price of unit area')

df.plot.scatter(x = 'X5 latitude', y = 'Y house price of unit area')

df.plot.scatter(x = 'X6 longitude', y = 'Y house price of unit area')

plot1.plot.scatter(x='Iterations', y = 'RMSE', ylim = (9,10))